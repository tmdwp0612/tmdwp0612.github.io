---
layout: single
title:  "동적 계획법(1)"
categories: Algorithm
tag : 
use_math : true
---

종만북, [kks227](https://blog.naver.com/kks227/220777103650)님의 블로그와 [바킹독님 유튜브](https://www.youtube.com/playlist?list=PLtqbFd2VIQv4O6D6l9HcD732hdrnYb6CY)를 공부하며 정리해보았다.



## #1 도입

* **알고리즘 디자인 패러다임**

  문제를 해결하기 위해 알고리즘이 채택한 전략이나 관점을 말한다.  많은 알고리즘들은 문제를 해결하는   
  과정에서 문제를 해결하는데 가장 중요한 깨달음 을 공유하는데, 여기서 일정한 패턴을 확인할 수 있다. 
  
  즉 어떤 알고리즘이 문제를 해결하는데 사용한 전략이 알고리즘 설계 패러다임이다.



* **다이나믹 프로그래밍**(Dynamic Programming : 앞으로는 DP라고 적겠다.)
  1. 동적 계획법 또한 주어진 문제를 작은 문제로 만든 뒤 답을 구하고, 작은 답을 이용해 원래 답을 구한다.
  
  2. 어떤 부분 문제가 두 개 이상의 서브 문제를 푸는데 사용된다면 이 문제의 답을 여러 번 다시 계산하는 대신 계산 결과를 메모해놓음으로써(Memoization) 속도향상을 꾀할 수 있다.
     
  3. 메모이제이션은 함수의 리턴값이 입력 값만으로 결정될 때, 참조적 투명성이 성립할 때에만 사용가능
  
  4. 캐시를 채울 때, 가장 큰 문제를 호출하고 나머지를 재귀적으로 호출하는 탑다운(Top-down) 방식이 있고, 반복문을 사용해 아래부터 채워가는 바텀업(bottom-up) 방식이 존재한다.
  
     

* 동적 계획법 레시피
  1. 주어진 문제를 완전 탐색으로 해결하는 방법을 떠올려 본다.
  2. 중복된 부분 문제를 한 번만 계산하도록 메모이제이션을 적용한다.

<br>

**[백준1562 계단수]**<https://www.acmicpc.net/problem/1562>

이전 자리에 오는 숫자가 다음 숫자를 결정한다.  
i번째숫자가 5이면 i+1을 채울때는 0~i-1에 무슨 숫자가 존재하든 상관없이 4or 6이다.  
12345.... 34545... 54345... 등에서 "i가 5일때 그 뒤는 어떻게 채워?" 라는 질문을 계속 하므로  
이 값을 한번만 구해서 적어놓아야 겠다고(Memoization) 생각 할 수 있다.



**[백준1509 팰린드롬 분할]**<https://www.acmicpc.net/problem/1509>

어떤 문자열을 가장 작은 수의 팰린드롬으로 분할하는 문제이다.  
k번째 칸을 채울 때, k와 팰린드롬을 이루는 i를 찾고 [i+1~n]을 재귀적으로 호출하는데 이때 부분 문제를 중복해서 호출하게 되므로 dp[st] : st부터 구한 팰린드롬 분할 개수 를 메모해 둘 수 있다.  
(부분 문자열 팰린드롬을 O(n) 에 판단하는 알고리즘은 24년8월 리뷰노트에 적어두었다.)

```c++
int func(int k) {
    if(k==s.size()) return 0;
    int& ret = dp[k];
    if(ret != -1) return ret;

    ret = 1e8;
    for(int i=k;i<s.size();i++) {
        if(pal[k][i]) ret=min(ret,1+func(i+1));
    }
    return ret;
}
```

**[백준14517 팰린드롬 개수 구하기(Large)]**<https://www.acmicpc.net/problem/14517>

문자열에 부분수열 중 팰린드롬 개수를 구하는 것,  여기서 부분수열은 연속하지 않아도 된다.  
i~j 에 존재하는 팰린드롬 개수를 dp\[i]\[j] 라고 하면  
$s[i] \neq s[j]$ 일 때 $dp[i][j] = dp[i+1][j] + dp[i][j-1] - dp[i+1][j-1]$   

$s[i] == s[j]$ 일 때 $dp[i][j] = dp[i+1][j] + dp[i][j-1] + 1$ 

<br>

**[백준1006 습격자 초라기]**<https://www.acmicpc.net/problem/1006>

1. 완전 탐색을 할때 반복되는 부분 문제를 생각해보면,   
   "주어진 칸 중 몇개의 칸이 칠해졌을 때 나머지를 채울때 필요한 값"  
   을 dp 배열에 적어놓고 싶어진다.
2. DP 문제의 난이도를 높이는 방법 중 하나가 **이 메모이제이션을 어렵게 하는 것**이라고 생각한다.   이 문제에서는  1부터 채워야 될까?  1,9 까지 채우고 다음칸으로 가야되나? 원형인데 어떻게 펼치지?  등의 고민을 요구한다.
3. 원형 처리는 1와 n-1에서 해결한다고 치면 ,  
   i번째 벽을 채울때 만나는 경우의 수는 xx ox xo  3가지이고 두문자는 안쪽바깥쪽의 처리여부이다.     따라서 $dp[10005][3]$ 배열을 선언하고, $dp[i][j]$ 는  i칸의 모양이 j일때 i~n을 채우는 최소값이다
4. 원형 처리는 1과n-1 사이에서 [ 안쪽만 연결, 바깥쪽만 연결, 둘다연결 , 연결X ] 4가지 경우로 시작을 하면서 처리해 주었다.

*두겹의 벽을 직접 처리하기 보다는 나타날 수 있는 케이스가*   
*한정적이라는 사실을 이용하는 것이 가장 중요했다!!*

<br>

### 최적화 문제

동적 계획법의 일반적인 사용처는 최적화 문제, 가장 좋은 답을 선택하는 문제의 해결이다. 

**[TRIANGLEPATH]**<https://www.algospot.com/judge/problem/read/TRIANGLEPATH>

맨위의 숫자에서 한칸씩 아래 or 오른쪽 아래로 내려갈때 경로의 최대 합을 찾는 문제이다.  
**잘못된** 메모이제이션을 살펴보자

```c++
int n, triangle[100][100];
int dp[100][100][max_num*100+1];

int path1(int y,int x,int sum) {
    if(y==n-1) return sum+triangle[y][x];
    int& ret = dp[y][x][sum];
    if(ret!=-1) return ret;
    
    sum+= triangle[y][x];
    return ret=max(path1(y+1,x+1,sum),path1(y+1,x,sum));
}
```

여기서 $dp[y][x][sum]$은 y x 이전까지 sum일때, 맨 아래줄 까지 갈때 얻는 최대 값을 저장한다.  

1. 메모리 초과의 우려가 있고
2. 특정 입력에 대해서는 완전 탐색과 같이 작동한다.

<br>

사실 (y,x) 에서 맨 아래로 가는 최대 값은 sum과 상관이 없다. 따라서 sum을 입력받지 않고   
$dp[y][x]$를 $(y,x)$ 에서 시작해서 맨 아래줄까지 가는 경로의 최대 합 이라고 정의하면  
메모리와 시간을 줄일 수 있다. 

어떤 경로로 이 부분 문제에 도착했건 관계 없이 남은 부분 문제를 항상 최적으로 풀어도 상관없다 
는 성질을 **최적 부분 구조** 라고 한다. 

**부분 문제의 최적해**를 이용해 전체 문제의 최적해를 구할 수 있다면 **최적 부분 구조**가 성립한다.    
→ 따라서 캐시 메모리에 부분 문제의 최적해를 담는 해결법을 생각해 볼 수 있다. 



## #2 실제 답 계산하기

최적화 문제를 풀 때 최적해의 값만을 계산하는 것이 아닌,  
어떤 경로를 통해 최적해에 도착하는지 직접 계산해보자

**[백준 2213 트리의 독립집합]**<https://www.acmicpc.net/problem/2213>  

1이 루트인 트리가 주어졌다고 하면, 그 아래의 어떤 노드를 루트로하는 서브트리의 최대 합은  
위에서 어떤 노드들을 선택했는지 상관 없다는 것! → **최적부분구조**

인접노드를 둘다 선택할 수 없다는 조건만 고려해주면  
 $dp[10001][2]$ : i가 루트인 서브트리의 최대값  j==0 이면 i번째 안칠함 , j==1 이면 칠함 

어떤 노드를 사용했는지 구하는 tracking함수는 **메모이제이션과 비슷한 구조**로 정점을 탐색하며,  
간단하게 루트를 사용한 경우에 노드를 배열에 추가해주는 식으로 구현했다.

**[백준3687 성냥개비]**<https://www.acmicpc.net/problem/3687>

가장 큰 수는 1과 7만을 이용해서 만들 수 있지만 작은 수는 DP를 사용해야 한다.

다행히 성냥이 100개이므로 재귀 함수에서 10개의 숫자를 전부 시도해보아도 O(10*n) 으로 충분히 가능하다. $dp[i] = min(dp[i],dp[i-j]) (0<=j<=9)$   
성냥이 남는경우, 0이 맨앞에 오는 경우는 예외처리를 해야한다.

**[백준2494 숫자 맞추기]**<https://www.acmicpc.net/problem/2494>

최적화 문제를 해결 할 때, 이전에 선택한 것에대한 정보를 최소화 시켜서 메모이제이션을 효과적으로  했던 경험이 있을 것이다. 이 문제도 $i$번째 나사를 돌릴때 그 위에서 어떤 걸 몇개를 돌렸는지는 상관이 없고, 총 몇번 왼쪽으로 돌렸는지만 아래에 영향을 미친다. 

따라서 $dp[i][k]$ : 지금까지 왼쪽으로 k번 돌렸을때, i번부터 아래 나사들을 채우는 최적 값  
10번 돌리면 1바퀴니까 k<10 이다.

각 (i,k) 에서 최적값을 만드는 nxt position 값을 저장해놓고 tracking 함수로 추적하며 각각의 회전 값을 출력해 주었다.

**[백준1023 괄호문자열]**<https://www.acmicpc.net/problem/1023>

