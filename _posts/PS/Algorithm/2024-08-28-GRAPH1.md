---
layout: single
title:  "그래프(1)"
categories: Algorithm
tag : 
use_math : true
---

## #1 도입

**그래프** : $G(V,E)$ 는 정점들의 집합$V$와 정점을 연결하는 간선의 집합$E$로 구성된 자료구조 

방향 그래프(directed graph) : 각 간선에 방향이 존재하는 그래프  
무향 그래프(undirected graph) : 간선에 방향이 없는 그래프  
가중치 그래프(weighted graph) : 각 간선에 가중치가 존재하는 그래프  
다중 그래프(multi graph) : 두 정점사이에 간선이 2개 이상 존재할 수 있는 그래프  
단순 그래프(simple graph) : 두 정점사이에 간선이 최대 한개만 존재하는 그래프  
이분 그래프(bipartite graph) : 그래프의 정점을 겹치지 않는 두 집합으로 나누어 서로 다른 그룹에 속						     한 정점들 간에만 간선이 존재하는 그래프  

트리 : 무방향이면서 사이클이 없는 연결그래프  
DAG(directed acyclic graph) : 사이클이 없는 방향 그래프



**구현 방식**

1. 인접 리스트

   ```c++
   vector<int> adj[10000];
   vector<pair<int,int> adj2[10000]; //weight , vertex
   ```

   * 공간복잡도 : $O(V+E)$
   * 정점 u,v가 연결되어있는지 확인 : $O(min(deg(u),deg(v)))$
   * 정점 u와 연결된 모든 정점 확인 : $O(deg(u))$

2. 인접 행렬

   ~~~c++
   vector<vector<bool>> adj[1000][1000];
   vector<vector<int>> adj2[1000][1000];
   ~~~

   * 공간복잡도 : $O(V^2)$
   * 정점 u,v가 연결되어있는지 확인 : $O(1)$
   * 정점 u와 연결된 모든 정점 확인 : $O(u)$



## #2 깊이 우선 탐색

**DFS**의 중요한 특성은 더 따라갈 간선이 없다면 이전으로 되돌아 간다는 점인데, **재귀 호출**을 이용하면 함수가 종료하면 호출한 위치로 다시 돌아가기 때문에  간단히 구현 할 수 있다.

시간 복잡도 : $O(V+E)$

### 위상 정렬

이수 체계도 처럼 작업 간에 순서가 존재할 때, 의존 관계를 **DAG**의 간선으로 표현할 수 있다.  
이때 의존성 그래프의 정점을 배열하는 문제를 위상정렬 이라고 한다.

**\<Indegree체크하는 방식>**

1. indegree 가 0인 정점을 큐에 넣는다.
2. 큐에서 정점을 꺼내고 위상 정렬 결과에 추가한다
3. 그 정점에 연결된 정점의 indegree 1감소, 0이면 큐에추가

**\<DFS>방식**

1. dfsAll() 을 수행하며 dfs가 종료할때마다 현재 정점의 번호를 기록하고 dfsAll() 종료시 순서를 뒤집는다.
2. 

**[백준3665 최종 순위]**<https://www.acmicpc.net/problem/3665>

1. 두팀의 순위 바뀌는 것을 그 두팀사이의 간선 방향만 바꿔주는 것으로 처리할 수 있는 이유는  
   올바른 입력의 경우 상대적인 순위가 바뀐 **모든** 팀의 목록을 주기 때문이다.
2. 큐의 사이즈가 2이상이 되면 ? , 사이클이 생기면 IMPOSSIBLE 이다
3. 사이클이 생기면 큐에 안들어가는 팀이 생긴다.
