---
layout: single
title:  "24년 8월"
categories: ReviewNote
tag : 
use_math : true
---

# 240817

* **[백준1562](https://www.acmicpc.net/problem/1562)**

```c++
int& ret = dp[a][b][c];
```

Top-down DP 재귀함수에서 참조자 표시& 를 빠트렸더니 시간초과가 났다.  
이게 실행시간에 큰 영향을 끼치는 구나..

<br>

* [**백준14444**](https://www.acmicpc.net/problem/14444)

  부분 문자열들의 팰린드롬을 O(n) 에 탐색하는 [**Manacher's algorithm**](https://algospot.com/wiki/read/Manacher%27s_algorithm)에 대해 알아보자!   
  (알고리즘을 검색해서 이미지를 하나 열어놓고 읽자)
  
  1. 팰린드롬은 중간의 문자를 기준으로 양 옆이 대칭을 이룬다 aabaa  roddor  
     - **A[i]** : i중심일때 반지름의 최대 길이
     - **R**     : j<i 인 모든 j대해 max(j+A[j])
     - **p**     : R을 만드는 index j<br>
  
  2. 0~n-1 을 탐색하며 A[i]를 채우는데, 이 때 $i<=R$ 이면 이번에 우리가 살펴볼 $i$ 가  
     이전에 등장한 팰린드롬의 반지름 속에 속해있다는 것이다<br>
  
  3. 그럼 p를 기준으로 반대편에 있는 $i^{'}$  을 살펴보고 싶어지는데 ,   
     $i^{'}$ 부터 왼쪽 반지름 끝까지 , $i$ 부터 오른쪽 반지름 끝(**R**) 까지 는 당연히 팰린드롬이니까 같다.<br>
  
  4. 따라서  $min(R-i,A[i^{'}])$  의 반지름을 $i$는 먼저 확정짓고 갈 수 있다는 것 이다.<br>
  
  5. 짝수 팰린드롬은 숫자 사이사이에 더미 문자를 넣어서 찾을 수 있다.'a#b#c#d#d#c#b#a'
  
  6. **시간복잡도**
  
     * A[i] == A[2*p-i] 인 경우, i+A[i]<R  인경우 내부 반복문을 돌지 않는다
     * A[i] == R-i , A[i]==0 인 경우, i+A[i]>R 임을 의미하므로, R값을 증가시키는데, R<n 이고 감소하지 않으므로 , armotizedO(n) 에 동작한다
  
  7. **구현**
  
     ```c++
     int a[200004];
     
     int main(void) { 
         fastio
     
         string s; cin>>s;
         string str;
         for(int i=0;i<s.size();i++) {
             str += s[i];
             str += '#';
         }
         int len = str.size();
         int p = 0; int r = 0;
         for(int i=0;i<len;i++) {
             if(i<=r) {a[i] = min(r-i,a[2*p-i]);}
     
             for(int j=a[i];j<len;j++) {
                 if(i-j<0 || i+j>=len || str[i+j]!=str[i-j]) break;
                 a[i] = j;
             }
             if(i+a[i]>r) {r=i+a[i]; p=i;}
         }
         int ans = 0;
         for(int i=0;i<len;i++) {
             if(i%2==1) ans = max(ans,((a[i]+1)/2)*2);
             else ans = max(ans,1+(a[i]/2)*2);
         }
         cout<<ans;
     }
     ```
  
     문자열에 더미 문자를 바로 추가해주면 i가 홀수 일때는 \#이 중앙에 있고 반지름의 모양은  
     a#a# , a#a 이므로 $(a[i]+1)/2)\times2$ , <br> 
     i가 짝수일때는 숫자가 중앙이고 반지름은 #a#a , #a#모양 이므로  
     $1+(a[i]/2)\times2$ 처리 해주었다.

*나중에 **회문트리** 랑 **LCP 배열**이 무엇인지 개념만 찾아보고 다른 문제를 더 풀어보자!*







